/* -*- c++ -*- */
/* 
 * Copyright 2018 Anders Kal√∏r <anders@kaloer.com>.
 * 
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 * 
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <gnuradio/io_signature.h>
#include <gnuradio/blocks/wavfile.h>
#include "smu_waveform_sink_impl.h"
#include <cstdint>
#include <ctime>
#include <fcntl.h>
#include <volk/volk.h>
#include <gnuradio/math.h>

// The following is borrowed from file_sink_base.cc
// win32 (mingw/msvc) specific
#ifdef HAVE_IO_H
#include <io.h>
#endif
#ifdef O_BINARY
#define OUR_O_BINARY O_BINARY
#else
#define OUR_O_BINARY 0
#endif

// Should be handled via configure
#ifdef O_LARGEFILE
#define OUR_O_LARGEFILE O_LARGEFILE
#else
#define OUR_O_LARGEFILE
#endif

namespace gr {
  namespace rswaveforms {

    smu_waveform_sink::sptr
    smu_waveform_sink::make(const char *filename, unsigned int sample_rate)
    {
      return gnuradio::get_initial_sptr
        (new smu_waveform_sink_impl(filename, sample_rate));
    }

    /*
     * The private constructor
     */
    smu_waveform_sink_impl::smu_waveform_sink_impl(const char *filename, unsigned int sample_rate)
      : gr::sync_block("smu_waveform_sink",
                       gr::io_signature::make(1, 1, sizeof(gr_complex)),
                       gr::io_signature::make(0, 0, 0)),
        d_filename(filename),
        d_sample_rate(sample_rate)
    {
    }

    /*
     * Our virtual destructor.
     */
    smu_waveform_sink_impl::~smu_waveform_sink_impl()
    {
      write_file();
    }

    void
    smu_waveform_sink_impl::write_file() {
      int fd;
      FILE *fp;
      if((fd = open(d_filename,
                    O_WRONLY|O_CREAT|O_TRUNC|OUR_O_LARGEFILE|OUR_O_BINARY,
                    0664)) < 0) {
        perror(d_filename);
	return;
      }
      if((fp = fdopen(fd, "wb")) == NULL) {
        perror(d_filename);
        close(fd);
	return;
      }
      
      int N = d_buf.size();
      unsigned int alignment = volk_get_alignment();
      gr_complex* complex_arr_buf = (gr_complex*)volk_malloc(sizeof(gr_complex)*N, alignment);
      float* float_arr_buf = (float*)volk_malloc(sizeof(float)*N, alignment);
      uint16_t* uint16_buf = (uint16_t*)volk_malloc(sizeof(uint16_t), alignment);
      float* float_buf1 = (float*)volk_malloc(sizeof(float), alignment);
      float* float_buf2 = (float*)volk_malloc(sizeof(float), alignment);

      // Normalize
      // Index of maximum magnitude
      volk_32fc_index_max_16u(uint16_buf, &d_buf[0], N);
      // Multiply by inverse
      gr_complex scalar = gr_complex(1.0f/std::abs(d_buf[*uint16_buf]), 0.0f);
      volk_32fc_s32fc_multiply_32fc(complex_arr_buf, &d_buf[0], scalar, N);
      // Calculate the peak value
      volk_32fc_magnitude_squared_32f(float_arr_buf, complex_arr_buf, N);
      volk_32f_index_max_16u(uint16_buf, float_arr_buf, N);
      float peak_power_dBfs = -10.0*std::log10(float_arr_buf[*uint16_buf]);

      // Calculate RMS
      volk_32f_stddev_and_mean_32f_x2(float_buf1, float_buf2, float_arr_buf, N);
      float rms_dBfs = -10.0*std::log10(*float_buf2);

      // Quantization
      int16_t* out_i = (int16_t*)volk_malloc(sizeof(int16_t)*N, alignment);
      int16_t* out_q = (int16_t*)volk_malloc(sizeof(int16_t)*N, alignment);
      volk_32fc_deinterleave_real_32f(float_arr_buf, complex_arr_buf, N);
      volk_32f_s32f_convert_16i(out_i, float_arr_buf, 32767, N);
      volk_32fc_deinterleave_imag_32f(float_arr_buf, complex_arr_buf, N);
      volk_32f_s32f_convert_16i(out_q, float_arr_buf, 32767, N);

      // Write meta data
      fprintf(fp, "{TYPE: SMU-WV,0}");
      fprintf(fp, "{COMMENT: Generated by gr-rswaveforms}");
      std::time_t now = std::time(0);
      const std::tm *tm = std::localtime(&now);
      fprintf(fp, "{DATE: %04d-%02d-%02d;%02d:%02d:%02d}",
              tm->tm_year, tm->tm_mon, tm->tm_mday,
              tm->tm_hour, tm->tm_min, tm->tm_sec);
      fprintf(fp, "{CLOCK: %d}", d_sample_rate);
      fprintf(fp, "{LEVEL OFFS: %f,%f}", rms_dBfs, peak_power_dBfs);
      fprintf(fp, "{SAMPLES: %d}", N);
      fprintf(fp, "{WAVEFORM-%d: #", N*4+1);
      
      for(int i = 0; i < N; i++) {
        // Use the WAV function which takes care of endianess
        gr::blocks::wav_write_sample(fp, out_i[i], 2);
        gr::blocks::wav_write_sample(fp, out_q[i], 2);
      }
      fprintf(fp, "}");
      
      fclose(fp);

      volk_free(out_i);
      volk_free(out_q);
      volk_free(float_buf2);
      volk_free(float_buf1);
      volk_free(uint16_buf);
      volk_free(float_arr_buf);
      volk_free(complex_arr_buf);
    }

    int
    smu_waveform_sink_impl::work(int noutput_items,
        gr_vector_const_void_star &input_items,
        gr_vector_void_star &output_items)
    {
      const gr_complex *in = (const gr_complex*) input_items[0];

      // Buffer
      d_buf.insert(d_buf.begin(), &in[0], &in[noutput_items]);
      
      // Tell runtime system how many output items we produced.
      return noutput_items;
    }

  } /* namespace rswaveforms */
} /* namespace gr */

