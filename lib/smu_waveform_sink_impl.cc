/* -*- c++ -*- */
/* 
 * Copyright 2018 Anders Kal√∏r <anders@kaloer.com>.
 * 
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 * 
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <gnuradio/io_signature.h>
#include <gnuradio/blocks/wavfile.h>
#include "smu_waveform_sink_impl.h"
#include <cstdint>
#include <ctime>
#include <climits>
#include <fcntl.h>
#include <volk/volk.h>
#include <gnuradio/math.h>

// The following is borrowed from file_sink_base.cc
// win32 (mingw/msvc) specific
#ifdef HAVE_IO_H
#include <io.h>
#endif
#ifdef O_BINARY
#define OUR_O_BINARY O_BINARY
#else
#define OUR_O_BINARY 0
#endif

// Should be handled via configure
#ifdef O_LARGEFILE
#define OUR_O_LARGEFILE O_LARGEFILE
#else
#define OUR_O_LARGEFILE
#endif

namespace gr {
  namespace rswaveforms {

    smu_waveform_sink::sptr
    smu_waveform_sink::make(const char *filename, unsigned int sample_rate)
    {
      return gnuradio::get_initial_sptr
        (new smu_waveform_sink_impl(filename, sample_rate));
    }

    /*
     * The private constructor
     */
    smu_waveform_sink_impl::smu_waveform_sink_impl(const char *filename, unsigned int sample_rate)
      : gr::sync_block("smu_waveform_sink",
                       gr::io_signature::make(1, 1, sizeof(gr_complex)),
                       gr::io_signature::make(0, 0, 0)),
        d_fp(0),
        d_sample_rate(sample_rate),
        d_f_level_offs_field_width(8),
        d_f_level_offs_field_prec(6),
        d_f_samples_field_width(
                (unsigned int)std::ceil(std::log10(ULONG_MAX))),
        d_f_waveform_field_width(
                (unsigned int)std::ceil(std::log10(ULONG_MAX))),
        d_f_level_offs_pos(0),
        d_f_samples_pos(0),
        d_f_waveform_pos(0),
        d_peak_power_dBfs(0.0),
        d_acc_power(0.0),
        d_num_samples(0)
    {
      GR_LOG_DEBUG(d_logger, "constructor()");
      
      open_file(filename);
    }

    /*
     * Our virtual destructor.
     */
    smu_waveform_sink_impl::~smu_waveform_sink_impl()
    {
      close_file();
    }

    int
    smu_waveform_sink_impl::work(int noutput_items,
        gr_vector_const_void_star &input_items,
        gr_vector_void_star &output_items)
    {
      const gr_complex *in = (const gr_complex*) input_items[0];

      GR_LOG_DEBUG(d_logger, boost::format("work() %d") % noutput_items);
      // Write to file
      write_samples(in, noutput_items);
      
      // Tell runtime system how many output items we produced.
      return noutput_items;
    }

    void
    smu_waveform_sink_impl::open_file(const char *filename) {
      GR_LOG_DEBUG(d_logger, "open_file()");
      int fd;
      if((fd = open(filename,
                    O_WRONLY|O_CREAT|O_TRUNC|OUR_O_LARGEFILE|OUR_O_BINARY,
                    0664)) < 0) {
        perror(filename);
        return;
      }
      if((d_fp = fdopen(fd, "wb")) == NULL) {
        perror(filename);
        close(fd);
        return;
      }

      // Write header
      write_header();
    }

    void
    smu_waveform_sink_impl::write_header() {
      GR_LOG_DEBUG(d_logger, "write_header()");
      // Write meta data
      fprintf(d_fp, "{TYPE: SMU-WV,0}");
      fprintf(d_fp, "{COMMENT: Generated by gr-rswaveforms}");
      std::time_t now = std::time(0);
      const std::tm *tm = std::localtime(&now);
      fprintf(d_fp, "{DATE: %04d-%02d-%02d;%02d:%02d:%02d}",
              tm->tm_year, tm->tm_mon, tm->tm_mday,
              tm->tm_hour, tm->tm_min, tm->tm_sec);
      fprintf(d_fp, "{CLOCK: %d}", d_sample_rate);
      // We don't know this yet.
      fprintf(d_fp, "{LEVEL OFFS: ");
      d_f_level_offs_pos = ftell(d_fp);
      fprintf(d_fp, "%+0*.*f,%+0*.*f}",
              d_f_level_offs_field_width, d_f_level_offs_field_prec, 0.0f,
              d_f_level_offs_field_width, d_f_level_offs_field_prec, 0.0f);
      fprintf(d_fp, "{SAMPLES: ");
      d_f_samples_pos = ftell(d_fp);
      fprintf(d_fp, "%0*d}",
              d_f_samples_field_width, 0);
      fprintf(d_fp, "{WAVEFORM-");
      d_f_waveform_pos = ftell(d_fp);
      fprintf(d_fp, "%0*d: #}",
              d_f_waveform_field_width, 0);
    }

    void
    smu_waveform_sink_impl::update_header(float rms, float peak, int num_samples) {
      GR_LOG_DEBUG(d_logger, "update_header()");
      fseek(d_fp, d_f_level_offs_pos, SEEK_SET);
      fprintf(d_fp, "%+0*.*f,%+0*.*f",
              d_f_level_offs_field_width, d_f_level_offs_field_prec, rms,
              d_f_level_offs_field_width, d_f_level_offs_field_prec, peak);
      fseek(d_fp, d_f_samples_pos, SEEK_SET);
      fprintf(d_fp, "%0*d", d_f_samples_field_width, num_samples);
      fseek(d_fp, d_f_waveform_pos, SEEK_SET);
      fprintf(d_fp, "%0*d", d_f_waveform_field_width, num_samples*4+1);
    }

    void
    smu_waveform_sink_impl::write_samples(const gr_complex *data, int len) {
      GR_LOG_DEBUG(d_logger, "write_samples()");
      
      unsigned int alignment = volk_get_alignment();
      float *float_arr_buf = (float*)volk_malloc(sizeof(float)*len, alignment);
      float *float_buf = (float*)volk_malloc(sizeof(float), alignment);
      uint16_t *uint16_buf = (uint16_t*)volk_malloc(sizeof(uint16_t), alignment);
      int16_t *i_buf = (int16_t*)volk_malloc(sizeof(int16_t)*len, alignment);
      int16_t *q_buf = (int16_t*)volk_malloc(sizeof(int16_t)*len, alignment);
      
      // Quantization
      volk_32fc_deinterleave_real_32f(float_arr_buf, data, len);
      volk_32f_s32f_convert_16i(i_buf, float_arr_buf, 32768, len);
      volk_32fc_deinterleave_imag_32f(float_arr_buf, data, len);
      volk_32f_s32f_convert_16i(q_buf, float_arr_buf, 32768, len);

      // Write to file
      // We need to overwrite the last '}'
      fseek(d_fp, -1, SEEK_END);
      for(int i = 0; i < len; i++) {
        // Use the WAV function which takes care of endianess
        gr::blocks::wav_write_sample(d_fp, i_buf[i], 2);
        gr::blocks::wav_write_sample(d_fp, q_buf[i], 2);
      }
      fprintf(d_fp, "}");

      
      // Calculate new header values
      d_num_samples = d_num_samples + len;

      // Calculate new peak power
      volk_32fc_magnitude_squared_32f(float_arr_buf, data, len);
      volk_32f_index_max_16u(uint16_buf, float_arr_buf, len);
      float peak_power_dBfs = -10.0*std::log10(float_arr_buf[*uint16_buf]);
      if(peak_power_dBfs > d_peak_power_dBfs) {
        d_peak_power_dBfs = peak_power_dBfs;
      }

      // Update RMS
      volk_32f_accumulator_s32f(float_buf, float_arr_buf, len);
      d_acc_power = d_acc_power + (*float_buf);
      float rms_dBfs = -10.0*std::log10(d_acc_power/d_num_samples);
      
      // Update header
      update_header(rms_dBfs, d_peak_power_dBfs, d_num_samples);

      // Flush
      fflush(d_fp);

      volk_free(float_arr_buf);
      volk_free(float_buf);
      volk_free(uint16_buf);
      volk_free(i_buf);
      volk_free(q_buf);
    }

    void
    smu_waveform_sink_impl::close_file() {
      GR_LOG_DEBUG(d_logger, "close_file()");
      fclose(d_fp);
    }

  } /* namespace rswaveforms */
} /* namespace gr */

